// Code generated by go-swagger; DO NOT EDIT.

package api

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/runtime/security"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/dalet-oss/iris-api/server/api/dhcp"
	"github.com/dalet-oss/iris-api/server/api/dns"
)

// NewIrisdAPI creates a new Irisd instance
func NewIrisdAPI(spec *loads.Document) *IrisdAPI {
	return &IrisdAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		customConsumers:     make(map[string]runtime.Consumer),
		customProducers:     make(map[string]runtime.Producer),
		PreServerShutdown:   func() {},
		ServerShutdown:      func() {},
		spec:                spec,
		useSwaggerUI:        false,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,

		JSONConsumer: runtime.JSONConsumer(),

		JSONProducer: runtime.JSONProducer(),
		TxtProducer:  runtime.TextProducer(),

		DhcpCreateDHCPSubnetHandler: dhcp.CreateDHCPSubnetHandlerFunc(func(params dhcp.CreateDHCPSubnetParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.CreateDHCPSubnet has not yet been implemented")
		}),
		DhcpCreateDHCPSubnetReservationHandler: dhcp.CreateDHCPSubnetReservationHandlerFunc(func(params dhcp.CreateDHCPSubnetReservationParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.CreateDHCPSubnetReservation has not yet been implemented")
		}),
		DNSCreateDNSZoneHandler: dns.CreateDNSZoneHandlerFunc(func(params dns.CreateDNSZoneParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.CreateDNSZone has not yet been implemented")
		}),
		DNSCreateDNSZoneRecordHandler: dns.CreateDNSZoneRecordHandlerFunc(func(params dns.CreateDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.CreateDNSZoneRecord has not yet been implemented")
		}),
		DhcpDeleteDHCPSubnetHandler: dhcp.DeleteDHCPSubnetHandlerFunc(func(params dhcp.DeleteDHCPSubnetParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.DeleteDHCPSubnet has not yet been implemented")
		}),
		DhcpDeleteDHCPSubnetReservationHandler: dhcp.DeleteDHCPSubnetReservationHandlerFunc(func(params dhcp.DeleteDHCPSubnetReservationParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.DeleteDHCPSubnetReservation has not yet been implemented")
		}),
		DNSDeleteDNSZoneHandler: dns.DeleteDNSZoneHandlerFunc(func(params dns.DeleteDNSZoneParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.DeleteDNSZone has not yet been implemented")
		}),
		DNSDeleteDNSZoneRecordHandler: dns.DeleteDNSZoneRecordHandlerFunc(func(params dns.DeleteDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.DeleteDNSZoneRecord has not yet been implemented")
		}),
		DhcpDisableDHCPHandler: dhcp.DisableDHCPHandlerFunc(func(params dhcp.DisableDHCPParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.DisableDHCP has not yet been implemented")
		}),
		DNSDisableDNSZoneRecordHandler: dns.DisableDNSZoneRecordHandlerFunc(func(params dns.DisableDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.DisableDNSZoneRecord has not yet been implemented")
		}),
		DhcpEnableDHCPHandler: dhcp.EnableDHCPHandlerFunc(func(params dhcp.EnableDHCPParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.EnableDHCP has not yet been implemented")
		}),
		DNSEnableDNSZoneRecordHandler: dns.EnableDNSZoneRecordHandlerFunc(func(params dns.EnableDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.EnableDNSZoneRecord has not yet been implemented")
		}),
		DhcpGetAllDHCPSubnetReservationsHandler: dhcp.GetAllDHCPSubnetReservationsHandlerFunc(func(params dhcp.GetAllDHCPSubnetReservationsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.GetAllDHCPSubnetReservations has not yet been implemented")
		}),
		DhcpGetAllDHCPSubnetsHandler: dhcp.GetAllDHCPSubnetsHandlerFunc(func(params dhcp.GetAllDHCPSubnetsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.GetAllDHCPSubnets has not yet been implemented")
		}),
		DNSGetAllDNSServersHandler: dns.GetAllDNSServersHandlerFunc(func(params dns.GetAllDNSServersParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetAllDNSServers has not yet been implemented")
		}),
		DNSGetAllDNSZoneRecordsHandler: dns.GetAllDNSZoneRecordsHandlerFunc(func(params dns.GetAllDNSZoneRecordsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetAllDNSZoneRecords has not yet been implemented")
		}),
		DNSGetAllDNSZonesHandler: dns.GetAllDNSZonesHandlerFunc(func(params dns.GetAllDNSZonesParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetAllDNSZones has not yet been implemented")
		}),
		DhcpGetDHCPStatusHandler: dhcp.GetDHCPStatusHandlerFunc(func(params dhcp.GetDHCPStatusParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.GetDHCPStatus has not yet been implemented")
		}),
		DhcpGetDHCPSubnetHandler: dhcp.GetDHCPSubnetHandlerFunc(func(params dhcp.GetDHCPSubnetParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.GetDHCPSubnet has not yet been implemented")
		}),
		DhcpGetDHCPSubnetReservationHandler: dhcp.GetDHCPSubnetReservationHandlerFunc(func(params dhcp.GetDHCPSubnetReservationParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.GetDHCPSubnetReservation has not yet been implemented")
		}),
		DNSGetDNSServerHandler: dns.GetDNSServerHandlerFunc(func(params dns.GetDNSServerParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetDNSServer has not yet been implemented")
		}),
		DNSGetDNSZoneHandler: dns.GetDNSZoneHandlerFunc(func(params dns.GetDNSZoneParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetDNSZone has not yet been implemented")
		}),
		DNSGetDNSZoneRecordHandler: dns.GetDNSZoneRecordHandlerFunc(func(params dns.GetDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.GetDNSZoneRecord has not yet been implemented")
		}),
		HealthzHandler: HealthzHandlerFunc(func(params HealthzParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation Healthz has not yet been implemented")
		}),
		DhcpReloadDHCPHandler: dhcp.ReloadDHCPHandlerFunc(func(params dhcp.ReloadDHCPParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.ReloadDHCP has not yet been implemented")
		}),
		DhcpUpdateDHCPSubnetHandler: dhcp.UpdateDHCPSubnetHandlerFunc(func(params dhcp.UpdateDHCPSubnetParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.UpdateDHCPSubnet has not yet been implemented")
		}),
		DhcpUpdateDHCPSubnetReservationHandler: dhcp.UpdateDHCPSubnetReservationHandlerFunc(func(params dhcp.UpdateDHCPSubnetReservationParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dhcp.UpdateDHCPSubnetReservation has not yet been implemented")
		}),
		DNSUpdateDNSZoneHandler: dns.UpdateDNSZoneHandlerFunc(func(params dns.UpdateDNSZoneParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.UpdateDNSZone has not yet been implemented")
		}),
		DNSUpdateDNSZoneRecordHandler: dns.UpdateDNSZoneRecordHandlerFunc(func(params dns.UpdateDNSZoneRecordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation dns.UpdateDNSZoneRecord has not yet been implemented")
		}),

		// Applies when the "x-token" header is set
		KeyAuth: func(token string) (interface{}, error) {
			return nil, errors.NotImplemented("api key auth (key) x-token from header param [x-token] has not yet been implemented")
		},
		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*IrisdAPI Iris API Server */
type IrisdAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler
	useSwaggerUI    bool

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator

	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator

	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for the following mime types:
	//   - application/json
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for the following mime types:
	//   - application/json
	JSONProducer runtime.Producer
	// TxtProducer registers a producer for the following mime types:
	//   - text/plain
	TxtProducer runtime.Producer

	// KeyAuth registers a function that takes a token and returns a principal
	// it performs authentication based on an api key x-token provided in the header
	KeyAuth func(string) (interface{}, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// DhcpCreateDHCPSubnetHandler sets the operation handler for the create d h c p subnet operation
	DhcpCreateDHCPSubnetHandler dhcp.CreateDHCPSubnetHandler
	// DhcpCreateDHCPSubnetReservationHandler sets the operation handler for the create d h c p subnet reservation operation
	DhcpCreateDHCPSubnetReservationHandler dhcp.CreateDHCPSubnetReservationHandler
	// DNSCreateDNSZoneHandler sets the operation handler for the create DNS zone operation
	DNSCreateDNSZoneHandler dns.CreateDNSZoneHandler
	// DNSCreateDNSZoneRecordHandler sets the operation handler for the create DNS zone record operation
	DNSCreateDNSZoneRecordHandler dns.CreateDNSZoneRecordHandler
	// DhcpDeleteDHCPSubnetHandler sets the operation handler for the delete d h c p subnet operation
	DhcpDeleteDHCPSubnetHandler dhcp.DeleteDHCPSubnetHandler
	// DhcpDeleteDHCPSubnetReservationHandler sets the operation handler for the delete d h c p subnet reservation operation
	DhcpDeleteDHCPSubnetReservationHandler dhcp.DeleteDHCPSubnetReservationHandler
	// DNSDeleteDNSZoneHandler sets the operation handler for the delete DNS zone operation
	DNSDeleteDNSZoneHandler dns.DeleteDNSZoneHandler
	// DNSDeleteDNSZoneRecordHandler sets the operation handler for the delete DNS zone record operation
	DNSDeleteDNSZoneRecordHandler dns.DeleteDNSZoneRecordHandler
	// DhcpDisableDHCPHandler sets the operation handler for the disable d h c p operation
	DhcpDisableDHCPHandler dhcp.DisableDHCPHandler
	// DNSDisableDNSZoneRecordHandler sets the operation handler for the disable DNS zone record operation
	DNSDisableDNSZoneRecordHandler dns.DisableDNSZoneRecordHandler
	// DhcpEnableDHCPHandler sets the operation handler for the enable d h c p operation
	DhcpEnableDHCPHandler dhcp.EnableDHCPHandler
	// DNSEnableDNSZoneRecordHandler sets the operation handler for the enable DNS zone record operation
	DNSEnableDNSZoneRecordHandler dns.EnableDNSZoneRecordHandler
	// DhcpGetAllDHCPSubnetReservationsHandler sets the operation handler for the get all d h c p subnet reservations operation
	DhcpGetAllDHCPSubnetReservationsHandler dhcp.GetAllDHCPSubnetReservationsHandler
	// DhcpGetAllDHCPSubnetsHandler sets the operation handler for the get all d h c p subnets operation
	DhcpGetAllDHCPSubnetsHandler dhcp.GetAllDHCPSubnetsHandler
	// DNSGetAllDNSServersHandler sets the operation handler for the get all DNS servers operation
	DNSGetAllDNSServersHandler dns.GetAllDNSServersHandler
	// DNSGetAllDNSZoneRecordsHandler sets the operation handler for the get all DNS zone records operation
	DNSGetAllDNSZoneRecordsHandler dns.GetAllDNSZoneRecordsHandler
	// DNSGetAllDNSZonesHandler sets the operation handler for the get all DNS zones operation
	DNSGetAllDNSZonesHandler dns.GetAllDNSZonesHandler
	// DhcpGetDHCPStatusHandler sets the operation handler for the get d h c p status operation
	DhcpGetDHCPStatusHandler dhcp.GetDHCPStatusHandler
	// DhcpGetDHCPSubnetHandler sets the operation handler for the get d h c p subnet operation
	DhcpGetDHCPSubnetHandler dhcp.GetDHCPSubnetHandler
	// DhcpGetDHCPSubnetReservationHandler sets the operation handler for the get d h c p subnet reservation operation
	DhcpGetDHCPSubnetReservationHandler dhcp.GetDHCPSubnetReservationHandler
	// DNSGetDNSServerHandler sets the operation handler for the get DNS server operation
	DNSGetDNSServerHandler dns.GetDNSServerHandler
	// DNSGetDNSZoneHandler sets the operation handler for the get DNS zone operation
	DNSGetDNSZoneHandler dns.GetDNSZoneHandler
	// DNSGetDNSZoneRecordHandler sets the operation handler for the get DNS zone record operation
	DNSGetDNSZoneRecordHandler dns.GetDNSZoneRecordHandler
	// HealthzHandler sets the operation handler for the healthz operation
	HealthzHandler HealthzHandler
	// DhcpReloadDHCPHandler sets the operation handler for the reload d h c p operation
	DhcpReloadDHCPHandler dhcp.ReloadDHCPHandler
	// DhcpUpdateDHCPSubnetHandler sets the operation handler for the update d h c p subnet operation
	DhcpUpdateDHCPSubnetHandler dhcp.UpdateDHCPSubnetHandler
	// DhcpUpdateDHCPSubnetReservationHandler sets the operation handler for the update d h c p subnet reservation operation
	DhcpUpdateDHCPSubnetReservationHandler dhcp.UpdateDHCPSubnetReservationHandler
	// DNSUpdateDNSZoneHandler sets the operation handler for the update DNS zone operation
	DNSUpdateDNSZoneHandler dns.UpdateDNSZoneHandler
	// DNSUpdateDNSZoneRecordHandler sets the operation handler for the update DNS zone record operation
	DNSUpdateDNSZoneRecordHandler dns.UpdateDNSZoneRecordHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// PreServerShutdown is called before the HTTP(S) server is shutdown
	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
	PreServerShutdown func()

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// UseRedoc for documentation at /docs
func (o *IrisdAPI) UseRedoc() {
	o.useSwaggerUI = false
}

// UseSwaggerUI for documentation at /docs
func (o *IrisdAPI) UseSwaggerUI() {
	o.useSwaggerUI = true
}

// SetDefaultProduces sets the default produces media type
func (o *IrisdAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *IrisdAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *IrisdAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *IrisdAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *IrisdAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *IrisdAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *IrisdAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the IrisdAPI
func (o *IrisdAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}
	if o.TxtProducer == nil {
		unregistered = append(unregistered, "TxtProducer")
	}

	if o.KeyAuth == nil {
		unregistered = append(unregistered, "XTokenAuth")
	}

	if o.DhcpCreateDHCPSubnetHandler == nil {
		unregistered = append(unregistered, "dhcp.CreateDHCPSubnetHandler")
	}
	if o.DhcpCreateDHCPSubnetReservationHandler == nil {
		unregistered = append(unregistered, "dhcp.CreateDHCPSubnetReservationHandler")
	}
	if o.DNSCreateDNSZoneHandler == nil {
		unregistered = append(unregistered, "dns.CreateDNSZoneHandler")
	}
	if o.DNSCreateDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.CreateDNSZoneRecordHandler")
	}
	if o.DhcpDeleteDHCPSubnetHandler == nil {
		unregistered = append(unregistered, "dhcp.DeleteDHCPSubnetHandler")
	}
	if o.DhcpDeleteDHCPSubnetReservationHandler == nil {
		unregistered = append(unregistered, "dhcp.DeleteDHCPSubnetReservationHandler")
	}
	if o.DNSDeleteDNSZoneHandler == nil {
		unregistered = append(unregistered, "dns.DeleteDNSZoneHandler")
	}
	if o.DNSDeleteDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.DeleteDNSZoneRecordHandler")
	}
	if o.DhcpDisableDHCPHandler == nil {
		unregistered = append(unregistered, "dhcp.DisableDHCPHandler")
	}
	if o.DNSDisableDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.DisableDNSZoneRecordHandler")
	}
	if o.DhcpEnableDHCPHandler == nil {
		unregistered = append(unregistered, "dhcp.EnableDHCPHandler")
	}
	if o.DNSEnableDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.EnableDNSZoneRecordHandler")
	}
	if o.DhcpGetAllDHCPSubnetReservationsHandler == nil {
		unregistered = append(unregistered, "dhcp.GetAllDHCPSubnetReservationsHandler")
	}
	if o.DhcpGetAllDHCPSubnetsHandler == nil {
		unregistered = append(unregistered, "dhcp.GetAllDHCPSubnetsHandler")
	}
	if o.DNSGetAllDNSServersHandler == nil {
		unregistered = append(unregistered, "dns.GetAllDNSServersHandler")
	}
	if o.DNSGetAllDNSZoneRecordsHandler == nil {
		unregistered = append(unregistered, "dns.GetAllDNSZoneRecordsHandler")
	}
	if o.DNSGetAllDNSZonesHandler == nil {
		unregistered = append(unregistered, "dns.GetAllDNSZonesHandler")
	}
	if o.DhcpGetDHCPStatusHandler == nil {
		unregistered = append(unregistered, "dhcp.GetDHCPStatusHandler")
	}
	if o.DhcpGetDHCPSubnetHandler == nil {
		unregistered = append(unregistered, "dhcp.GetDHCPSubnetHandler")
	}
	if o.DhcpGetDHCPSubnetReservationHandler == nil {
		unregistered = append(unregistered, "dhcp.GetDHCPSubnetReservationHandler")
	}
	if o.DNSGetDNSServerHandler == nil {
		unregistered = append(unregistered, "dns.GetDNSServerHandler")
	}
	if o.DNSGetDNSZoneHandler == nil {
		unregistered = append(unregistered, "dns.GetDNSZoneHandler")
	}
	if o.DNSGetDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.GetDNSZoneRecordHandler")
	}
	if o.HealthzHandler == nil {
		unregistered = append(unregistered, "HealthzHandler")
	}
	if o.DhcpReloadDHCPHandler == nil {
		unregistered = append(unregistered, "dhcp.ReloadDHCPHandler")
	}
	if o.DhcpUpdateDHCPSubnetHandler == nil {
		unregistered = append(unregistered, "dhcp.UpdateDHCPSubnetHandler")
	}
	if o.DhcpUpdateDHCPSubnetReservationHandler == nil {
		unregistered = append(unregistered, "dhcp.UpdateDHCPSubnetReservationHandler")
	}
	if o.DNSUpdateDNSZoneHandler == nil {
		unregistered = append(unregistered, "dns.UpdateDNSZoneHandler")
	}
	if o.DNSUpdateDNSZoneRecordHandler == nil {
		unregistered = append(unregistered, "dns.UpdateDNSZoneRecordHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *IrisdAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *IrisdAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
	result := make(map[string]runtime.Authenticator)
	for name := range schemes {
		switch name {
		case "key":
			scheme := schemes[name]
			result[name] = o.APIKeyAuthenticator(scheme.Name, scheme.In, o.KeyAuth)

		}
	}
	return result
}

// Authorizer returns the registered authorizer
func (o *IrisdAPI) Authorizer() runtime.Authorizer {
	return o.APIAuthorizer
}

// ConsumersFor gets the consumers for the specified media types.
// MIME type parameters are ignored here.
func (o *IrisdAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
	result := make(map[string]runtime.Consumer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONConsumer
		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result
}

// ProducersFor gets the producers for the specified media types.
// MIME type parameters are ignored here.
func (o *IrisdAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
	result := make(map[string]runtime.Producer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONProducer
		case "text/plain":
			result["text/plain"] = o.TxtProducer
		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result
}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *IrisdAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the irisd API
func (o *IrisdAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *IrisdAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened
	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dhcp/subnet"] = dhcp.NewCreateDHCPSubnet(o.context, o.DhcpCreateDHCPSubnetHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dhcp/subnet/{subnetId}/reservation"] = dhcp.NewCreateDHCPSubnetReservation(o.context, o.DhcpCreateDHCPSubnetReservationHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dns/zone"] = dns.NewCreateDNSZone(o.context, o.DNSCreateDNSZoneHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dns/zone/{zoneId}/record"] = dns.NewCreateDNSZoneRecord(o.context, o.DNSCreateDNSZoneRecordHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/dhcp/subnet/{subnetId}"] = dhcp.NewDeleteDHCPSubnet(o.context, o.DhcpDeleteDHCPSubnetHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/dhcp/subnet/{subnetId}/reservation/{macID}"] = dhcp.NewDeleteDHCPSubnetReservation(o.context, o.DhcpDeleteDHCPSubnetReservationHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/dns/zone/{zoneId}"] = dns.NewDeleteDNSZone(o.context, o.DNSDeleteDNSZoneHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/dns/zone/{zoneId}/record/{recordId}"] = dns.NewDeleteDNSZoneRecord(o.context, o.DNSDeleteDNSZoneRecordHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dhcp/disable"] = dhcp.NewDisableDHCP(o.context, o.DhcpDisableDHCPHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dns/zone/{zoneId}/record/{recordId}/disable"] = dns.NewDisableDNSZoneRecord(o.context, o.DNSDisableDNSZoneRecordHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dhcp/enable"] = dhcp.NewEnableDHCP(o.context, o.DhcpEnableDHCPHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dns/zone/{zoneId}/record/{recordId}/enable"] = dns.NewEnableDNSZoneRecord(o.context, o.DNSEnableDNSZoneRecordHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dhcp/subnet/{subnetId}/reservation"] = dhcp.NewGetAllDHCPSubnetReservations(o.context, o.DhcpGetAllDHCPSubnetReservationsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dhcp/subnet"] = dhcp.NewGetAllDHCPSubnets(o.context, o.DhcpGetAllDHCPSubnetsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/server"] = dns.NewGetAllDNSServers(o.context, o.DNSGetAllDNSServersHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/zone/{zoneId}/record"] = dns.NewGetAllDNSZoneRecords(o.context, o.DNSGetAllDNSZoneRecordsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/zone"] = dns.NewGetAllDNSZones(o.context, o.DNSGetAllDNSZonesHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dhcp"] = dhcp.NewGetDHCPStatus(o.context, o.DhcpGetDHCPStatusHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dhcp/subnet/{subnetId}"] = dhcp.NewGetDHCPSubnet(o.context, o.DhcpGetDHCPSubnetHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dhcp/subnet/{subnetId}/reservation/{macID}"] = dhcp.NewGetDHCPSubnetReservation(o.context, o.DhcpGetDHCPSubnetReservationHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/server/{serverId}"] = dns.NewGetDNSServer(o.context, o.DNSGetDNSServerHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/zone/{zoneId}"] = dns.NewGetDNSZone(o.context, o.DNSGetDNSZoneHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dns/zone/{zoneId}/record/{recordId}"] = dns.NewGetDNSZoneRecord(o.context, o.DNSGetDNSZoneRecordHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/healthz"] = NewHealthz(o.context, o.HealthzHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dhcp/reload"] = dhcp.NewReloadDHCP(o.context, o.DhcpReloadDHCPHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/dhcp/subnet/{subnetId}"] = dhcp.NewUpdateDHCPSubnet(o.context, o.DhcpUpdateDHCPSubnetHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/dhcp/subnet/{subnetId}/reservation/{macID}"] = dhcp.NewUpdateDHCPSubnetReservation(o.context, o.DhcpUpdateDHCPSubnetReservationHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/dns/zone/{zoneId}"] = dns.NewUpdateDNSZone(o.context, o.DNSUpdateDNSZoneHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/dns/zone/{zoneId}/record/{recordId}"] = dns.NewUpdateDNSZoneRecord(o.context, o.DNSUpdateDNSZoneRecordHandler)
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *IrisdAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	if o.useSwaggerUI {
		return o.context.APIHandlerSwaggerUI(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *IrisdAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *IrisdAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *IrisdAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// AddMiddlewareFor adds a http middleware to existing handler
func (o *IrisdAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
	um := strings.ToUpper(method)
	if path == "/" {
		path = ""
	}
	o.Init()
	if h, ok := o.handlers[um][path]; ok {
		o.handlers[method][path] = builder(h)
	}
}
